<?php

namespace Ssms\Controllers;

use Ssms\Logger;

class VulnerabilityController
{
    private \PDO $pdo;

    public function __construct(\PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    //-----------------------------------------------------
    // Fetch all vulnerability data from the database
    //-----------------------------------------------------
    function getVulnerabilities($target_id) {
        // Start session if not already started
        if (session_status() === PHP_SESSION_NONE) session_start();

        // Check if user_id is set in the session
        if (!isset($_SESSION['user_id'])) {
            return [
                'status' => 400,
                'data' => ['error' => 'User ID is required']
            ];
        }

        $user_id = (int)$_SESSION['user_id'];

        // Check if the target is owned by the logged in person
        $stmt = $this->pdo->prepare("SELECT test_id FROM targets WHERE id = :target_id");
        $stmt->bindParam(':target_id', $target_id, \PDO::PARAM_INT);
        $stmt->execute();
        $target = $stmt->fetch(\PDO::FETCH_ASSOC);

        if (!$target) {
            Logger::write('error', 'Unauthorized access attempt to target ID ' . $target_id . ' by user ID ' . $user_id);
            return [
                'status' => 404,
                'data' => ['error' => 'Target not found']
            ];
        }        
        
        // Check if the test is owned by the logged in person or if the user is the pentester who created the test
        $stmt = $this->pdo->prepare("SELECT customer_id, pentester_id FROM tests WHERE id = :test_id");
        $stmt->bindParam(':test_id', $target['test_id'], \PDO::PARAM_INT);
        $stmt->execute();
        $test = $stmt->fetch(\PDO::FETCH_ASSOC);

        if (!$test || ($test['customer_id'] !== $user_id && $test['pentester_id'] !== $user_id)) {
            Logger::write('error', 'Unauthorized access attempt to test ID ' . $target['test_id'] . ' by user ID ' . $user_id);
            return [
                'status' => 403,
                'data' => ['error' => 'Forbidden: You do not have access to this test']
            ];
        }

        try {
            $stmt = $this->pdo->prepare("SELECT * FROM vulnerabilities WHERE target_id = :target_id");
            $stmt->bindParam(':target_id', $target_id, \PDO::PARAM_INT);
            $stmt->execute();
            $vulnerabilities = $stmt->fetchAll(\PDO::FETCH_ASSOC);
            
            Logger::write('info', 'Fetched vulnerabilities for target ID ' . $target_id . ': ' . json_encode($vulnerabilities));

            return [
                'status' => 200,
                'data' => ['vulnerabilities' => $vulnerabilities]
            ];
        } catch (\PDOException $e) {
            Logger::write('error', 'Database error: ' . $e->getMessage());
            return [
                'status' => 500,
                'data' => ['error' => 'Database error']
            ];
        }
    }

    //-----------------------------------------------------
    // Delete a vulnerability from the database
    //-----------------------------------------------------
    public function deleteVulnerability($vulnerability_id) {
        // Start session if not already started
        if (session_status() === PHP_SESSION_NONE) session_start();

        // Check if user_id is set in the session
        if (!isset($_SESSION['user_id'])) {
            return [
                'status' => 400,
                'data' => ['error' => 'User ID is required']
            ];
        }

        $user_id = (int)$_SESSION['user_id'];

        // Check if the vulnerability exists
        $stmt = $this->pdo->prepare("SELECT target_id FROM vulnerabilities WHERE id = :vulnerability_id");
        $stmt->bindParam(':vulnerability_id', $vulnerability_id, \PDO::PARAM_INT);
        $stmt->execute();
        $vulnerability = $stmt->fetch(\PDO::FETCH_ASSOC);

        if (!$vulnerability) {
            Logger::write('error', 'Unauthorized access attempt to vulnerability ID ' . $vulnerability_id . ' by user ID ' . $user_id);
            return [
                'status' => 404,
                'data' => ['error' => 'Vulnerability not found']
            ];
        }

        // Check if the target is owned by the logged in person
        $stmt = $this->pdo->prepare("SELECT test_id FROM targets WHERE id = :target_id");
        $stmt->bindParam(':target_id', $vulnerability['target_id'], \PDO::PARAM_INT);
        $stmt->execute();
        $target = $stmt->fetch(\PDO::FETCH_ASSOC);

        if (!$target) {
            Logger::write('error', 'Unauthorized access attempt to target ID ' . $vulnerability['target_id'] . ' by user ID ' . $user_id);
            return [
                'status' => 404,
                'data' => ['error' => 'Target not found']
            ];
        }        
        
        // Check if the test is owned by the logged in person or if the user is the pentester who created the test
        $stmt = $this->pdo->prepare("SELECT customer_id, pentester_id FROM tests WHERE id = :test_id");
        $stmt->bindParam(':test_id', $target['test_id'], \PDO::PARAM_INT);
        $stmt->execute();
        $test = $stmt->fetch(\PDO::FETCH_ASSOC);

        if (!$test || ($test['customer_id'] !== $user_id && $test['pentester_id'] !== $user_id)) {
            Logger::write('error', 'Unauthorized access attempt to test ID ' . $target['test_id'] . ' by user ID ' . $user_id);
            return [
                'status' => 403,
                'data' => ['error' => 'Forbidden: You do not have access to this test']
            ];
        }

        try {
            $stmt = $this->pdo->prepare("DELETE FROM vulnerabilities WHERE id = :vulnerability_id");
            $stmt->bindParam(':vulnerability_id', $vulnerability_id, \PDO::PARAM_INT);
            $stmt->execute();

            Logger::write('info', 'Deleted vulnerability ID ' . $vulnerability_id . ' by user ID ' . $user_id);

            return [
                'status' => 200,
                'data' => ['message' => 'Vulnerability deleted successfully']
            ];
        } catch (\PDOException $e) {
            Logger::write('error', 'Database error: ' . $e->getMessage());
            return [
                'status' => 500,
                'data' => ['error' => 'Database error']
            ];
        }
    }
}